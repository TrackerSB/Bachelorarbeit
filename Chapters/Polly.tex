\chapter{Polly}
One of the numerous subprojects of the \llvm is Polly\footnote{The name \enquote{Polly} is a combination of \enquote{Polyhedral} and \enquote{\llvm}. \cite{PollyGrosser}} which provides plenty of options for automatic optimizations based on the polyhedral model operating on \llvmir.

\section{History}
\begin{wrapfigure}{l}{.5\textwidth}
    \caption[The logo of Polly Labs]{The Logo of Polly Labs \cite{PollyLabsLogo}}
    \includegraphics[width=.5\textwidth]{gfx/pollylabs.png}
\end{wrapfigure}
Polly is a practical implementation of the polyhedral model.\\
Before Polly there already existed an earlier implementation accessible using gcc.
The component for gcc was called Graphite and included \pcp which is an independant interface between the \ir of gcc called GIMPLE\footnote{\draftnote{The name \enquote{GIMPLE} is a result of \enquote{gcc} and \enquote{Simple II}, on which GIMPLE is based. \cite{GenericGimple}}} and the internal \ir \gpoly . \cite{GrosserGraphite, gccGimple, gccGraphite} \draftnote{TODO: Make it more precisly}
The problem with it was, that GIMPLE is not made for being human readable.
As consequence to ease developing and to avoid plenty of bugs the implementation was transfered to be used with \llvm, whose \ir is more human readable.
Another advantage arises due to the fact, that \llvm is not bound to C or C++.
As result the optimizations can be applied to even more programming languages. \draftnote{Really?}\\
Currently Polly has to be loaded serving as a \llvm plugin.
In future releases Polly is going to be integrated directly into \llvm instead.

\section{The pipeline of Polly}
Polly is embeded in pipeline of \llvm due to its a plugin.
More precisly it is called by the \opt (\autoref{subsec:optimizer}).
But before being able to use Polly with the \opt the option \texttt{-O3} has to specified when \llvmir is generated by the clang frontend. \draftnote{Why?}
Afterwards the library of Polly and its additional options can be loaded.
\begin{figure}[!ht]
    \caption[The pipeline of Polly]{The pipeline of Polly \cite{PollyPresentation}}
    \centering
    \begin{tikzlegend}
        \coordinate(clang);
        \node(opt)[llvmIrNode, right=of clang]{\ac{LLVM} Optimizer};
        \node(polly)[llvmIrNode, below=of opt]{\ac{LLVM} Polly};
        \coordinate[right=of opt](generator);
        \path[llvmIrPath] (clang) to (opt);
        \path[llvmIrPath, bend right] (opt.south west) to node[auto, swap]{SCoP Detection} (polly);
        \path[llvmIrPath, bend right] (polly) to node[auto, swap]{Code Generation} (opt.south east);
        \path[llvmIrPath] (opt) to (generator);
        \path[llvmIrPath] (polly) edge[loop below] ();
        \path[llvmIrPath] (opt) edge[loop above] node[auto]{Pass} ();
    \end{tikzlegend}
\end{figure}\\
For understanding which way Polly applies optimizations there are two essential terms.
On the one hand it is \enquote{region} on the other hand it is \enquote{\scop}.
\subsection{Definition region}\label{subsec:definitionRegion}
In \cite[chapter 9.7.1, p.~672]{Drachenbuch} a region is defined as:
\begin{comment}
    Seite 672, Chapter 9. Machine-independent optimizations, 9.7.1 Regions
\end{comment}
\begin{quote}
    Formally, a region of a flow graph is a collection of nodes N and edges E such that:
    \begin{enumerate}
        \item There is a header h in N that dominates all the nodes in N.
        \item If some node m can reach a node n in N without going through h, then m is also in N.
        \item E is the set of all the control flow edges between nodes \(n_1\) and \(n_2\) in N, except (possibly) for some that enter h.
    \end{enumerate}
\end{quote}
In \autoref{fig:exampleRegion} the regions of \autoref{lst:matmulll} are shown.
\begin{figure}[!ht]
    \centering
    \caption{The regions of \autoref{lst:matmulll}}
    \label{fig:exampleRegion}
    \includegraphics[width=\textwidth]{gfx/matmulRegions.png}
\end{figure}\\
For visualizing the regions of \autoref{lst:matmulcpp} a dot file is generated using the option \texttt{-view-regions-only}:
\begin{enumerate}
    \item Translate the C++ sourcecode into \llvmir (\autoref{lst:matmulll})\\
        \texttt{clang -S -emit-llvm matmul.cpp -o matmul.ll}
    \item Generate the regiontree\\
        \texttt{opt -view-regions-only matmul.ll}
\end{enumerate}
\subsection{Definition SCoP}\label{subsec:definitionScop}
\begin{comment}
    Copy\&pasted from polly/lib/Analysis/ScopDetection.cpp

    A static control part (Scop) is a subgraph of the control flow graph (CFG)
    that only has statically known control flow and can therefore be described
    within the polyhedral model.

    Every Scop fulfills these restrictions:
    * It is a single entry single exit region
    * Only affine linear bounds in the loops

    Every natural loop in a Scop must have a number of loop iterations that can
    be described as an affine linear function in surrounding loop iterators or
    parameters. (A parameter is a scalar that does not change its value during
    execution of the Scop).
    * Only comparisons of affine linear expressions in conditions
    * All loops and conditions perfectly nested

    The control flow needs to be structured such that it could be written using
    just 'for' and 'if' statements, without the need for any 'goto', 'break' or
    'continue'.

    * Side effect free functions call

    Function calls and intrinsics that do not have side effects (readnone)
    or memory intrinsics (memset, memcpy, memmove) are allowed.
\end{comment}

\begin{comment}
    A \scop is a certain type of region on which optimizations in top of the polyhedral model can be performed.
    More precisly it is a subgraph of the \cfg that only has statically known control flow and can therefore be described within the polyhedral model.
    Every \scop fulfills these restrictions according to ScopDetection:
    \begin{itemize}
        \item It is a single entry single exit region (\autoref{subsec:definitionRegion}).
        \item Only affine linear bounds in the loops.\\
            Every natural loop in a \scop must have a number of loop iterations that can be described as an affine linear function in surrounding loop iterators or parameters. (A parameter is a scalar that does not change its value during execution of the Scop).
        \item Only comparisons of affine linear expressions in conditions.
        \item All loops and conditions perfectly nested.\\
            The control flow needs to be structured such that it could be written using just \mintinline{c++}{for} and \mintinline{c++}{if} statements, without the need for any \mintinline{c++}{goto}, \mintinline{c++}{break} or \mintinline{c++}{continue}.
        \item Side effect free functions call.\\
            Function calls and intrinsics that do not have side effects (readnone) or \enquote{memory intrinsics (\mintinline{c++}{memset, memcpy, memmove}) are allowed}.
    \end{itemize}\cite{ScopDetection.cpp}
\end{comment}

\begin{comment}
    The polyhedron model puts restrictions on the kind of programs that can be optimized.
    To be able to model a code region, it must have \textit{static control}.
    A code region with static control is called a static-control part or SCoP, for short. Loops should be for loops.
    A loop’s limits must depend only on structure parameters, numerical constants, and iteration variables of the enclosing loops.
    Structure parameters are integer variables whose values remain unchanged inside a SCoP.
    The statements in a SCoP may operate on linear data structures (typically arrays).
    Loop limits and array indices must be affine functions of the iteration variables and structure parameters. \cite{GanserIterativeSchedule}
\end{comment}

\begin{comment}
    May use quiet mathematical description of \cite{PolyhedralEmpiricalStudy}.
\end{comment}

A \scop is a specific region with further restrictions for being representable by the polyhedral model.\\
For being a valid \scop such a region has to have \enquote{static control}.
This includes that the region is a single entry single exit region, the loops within have to have only affine linear bounds, these limits of the loops must depend only on structure parameters\footnote{Structure parameter are integer variables whose values remain unchanged inside a \scop.}, numerical constants and iteration variables of enclosing loops. \cite{GanserIterativeSchedule, ScopDetection.cpp}
Further a toplevel region can not be a \scop in Polly. \draftnote{Per definition? Why?}
This means a \scop has maximum size if its parent is the toplevel region.\\
The visualization of the \scops of \autoref{lst:matmulcpp} is shown in \autoref{fig:exampleScop}.
\begin{figure}[!ht]
    \centering
    \caption{The SCoPs of \autoref{lst:matmulcpp}}
    \label{fig:exampleScop}
    \includegraphics[height=15cm]{gfx/matmulScops.png}
\end{figure}\\
The dot file is generated by the option \texttt{-view-scops-only}:
\begin{enumerate}
    \item Translate the C++ sourcecode into \llvmir (\autoref{lst:matmulllO3})\\
        \texttt{clang -S -emit-llvm \textbf{-O3} matmul.cpp -o matmul.ll}
    \item Prepare the \llvmir for Polly (\autoref{lst:matmulpreoptll})\\
        \texttt{opt -S -load LLVMPolly.so -polly-canonicalize matmul.ll > matmul.preopt.ll}
    \item Generate the \scop tree\\
        \texttt{opt -load LLVMPolly.so -disable-output -view-scops-only matmul.preopt.ll}
\end{enumerate}

\section{SCoPDetection}
To detect these \scops Polly searches for candidates.
This is done by an optimistic prediction \draftnote{(?)} assuming the following points to not occure:
\begin{description}
    \item[Aliasing] Overlapping of the memory of variables \eg poiner onto some element of an array.
    \item[Inbounds] \draftnote{LLVM verwendet nur Pointer, keine Arrays. Eindimensionale Arrays rekonstruiert auf mehrdimensionale. => Abweichung Länge?}
    \item[Wrapping] Over- or underflow of short, integer,...
    \item[unsigned] \Eg overflow when using an unsigned integer as signed integer.
    \item[complexity] \draftnote{zu komplex?}
    \item[unprofitable] Overhead for generation of code extending the possible speedup.
    \item[errorBlock]
    \item[infiniteLoop]
    \item[invariantLoad]
    \item[delinearization]
\end{description}
\begin{comment}
    Copy\&pasted from ScopInfo.cpp

    STATISTIC(AssumptionsAliasing, "Number of aliasing assumptions taken.");
    STATISTIC(AssumptionsInbounds, "Number of inbounds assumptions taken.");
    STATISTIC(AssumptionsWrapping, "Number of wrapping assumptions taken.");
    STATISTIC(AssumptionsUnsigned, "Number of unsigned assumptions taken.");
    STATISTIC(AssumptionsComplexity, "Number of too complex SCoPs.");
    STATISTIC(AssumptionsUnprofitable, "Number of unprofitable SCoPs.");
    STATISTIC(AssumptionsErrorBlock, "Number of error block assumptions taken.");
    STATISTIC(AssumptionsInfiniteLoop, "Number of bounded loop assumptions taken.");
    STATISTIC(AssumptionsInvariantLoad,
              "Number of invariant loads assumptions taken.");
    STATISTIC(AssumptionsDelinearization,
              "Number of delinearization assumptions taken.");
\end{comment}
Afterwards for every found candidate an optimized version of code is generated, which is surrounded by runtime checks for determing the provability of the correctness of the taken assumptions.
When the proof holds true at execution, the optimized version of the code is continuing execution.
Otherwise the execution jumps to the unoptimized version of the affected section.
\draftnote{
    \begin{itemize}
        \item Keine konservative Abschätzung
        \item Optimistische Abschätzung
            \begin{itemize}
                \item Annahme: Abhängigkeit existiert nicht
                \item Beweis zur Laufzeit (Laufzeitchecks)
                \item Test oft durch Kontradiktion => Z.T immer zurückspringen und keine Generierung von Code
                \item Falls nicht beweisbar, zurückspringen in unoptimierten Code
            \end{itemize}
    \end{itemize}
}
