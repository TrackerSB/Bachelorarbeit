\chapter{Polly}
Polly\footnote{The name \enquote{Polly} is combination of \enquote{Polyhedral} and \enquote{\llvm}. \cite{PollyGrosser}} is one of the numerous subprojects of \llvm and provides ways for automatic optimizations based on the polyhedral model operating on \llvmir.

\section{Geschichte}
Polly was first described in the publication \cite{PollyGrosser}. TODO: More information?

\section{The pipeline of Polly}
Polly uses the same pipeline as \llvm but it extends the \opt but when generating \llvmir using the clang frontend the flag \texttt{-O3} has to be specified.
Afterwards the additional options implemented by Polly can be used specifying flags added to the \opt when loading the library of Polly (\autoref{subsec:optimizer}).
\begin{figure}[h]
    \caption{Die Pipeline von Polly \cite{PollyPresentation}}
    \centering
    \begin{tikzpicture}
        \coordinate(clang);
        \node(opt)[llvmIrNode, right=of clang]{\ac{LLVM} Optimizer};
        \node(polly)[llvmIrNode, below=of opt]{\ac{LLVM} Polly};
        \coordinate[right=of opt](generator);
        \path[llvmIrPath] (clang) to (opt);
        \path[llvmIrPath, bend right] (opt.south west) to node[auto, swap]{SCoP Detection} (polly);
        \path[llvmIrPath, bend right] (polly) to node[auto, swap]{Code Generation} (opt.south east);
        \path[llvmIrPath] (opt) to (generator);
        \path[llvmIrPath] (polly) edge[loop below] ();
    \end{tikzpicture}
\end{figure}\\
There are two essential terms for understanding Polly. On the one hand it is \enquote{region} on the other hand it is \enquote{\scop}.
\subsection{Definition region}\label{subsec:definitionRegion}
In \cite[chapter 9.7.1, p.~672]{Drachenbuch} a region is defined as:
\begin{comment}
    Seite 672, Chapter 9. Machine-independent optimizations, 9.7.1 Regions
\end{comment}
\begin{quote}
    Formally, a region of a flow graph is a collection of nodes N and edges E such that:
    \begin{enumerate}
        \item There is a header h in N that dominates all the nodes in N.
        \item If some node m can reach a node n in N without going through h, then m is also in N.
        \item E is the set of all the control flow edges between nodes \(n_1\) and \(n_2\) in N, except (possibly) for some that enter h.
    \end{enumerate}
\end{quote}
In \autoref{fig:exampleRegion} some sourcecode and its corresponding regions are shown.
\begin{figure}[!ht]
    \caption{A simple example of regions}
    \label{fig:exampleRegion}
    \begin{minipage}{.7\textwidth}
        \inputminted{c++}{cpp/matmul.cpp}
    \end{minipage}
    \begin{minipage}{.2\textwidth}
        \includegraphics[height=12cm]{gfx/matmulRegions.png}
    \end{minipage}
\end{figure}\\
For visualizing the regions of this program a dot file was generated executing the following steps/commands:
\begin{enumerate}
    \item Translate the C++ sourcecode into \llvmir (\autoref{lst:matmulll})\\
        \texttt{clang -S -O3 -emit-llvm matmul.cpp -o matmul.ll}
    \item Prepare the \llvmir for Polly (\autoref{lst:matmulpreoptll})\\
        \texttt{opt -load LLVMPolly.so -S -polly-canonicalize matmul.ll > matmul.preopt.ll}
    \item Generate the dot file\\
        \texttt{opt -load LLVMPolly.so -view-regions-only matmul.preopt.ll}
\end{enumerate}
\subsection{Definition SCoP}\label{subsec:definitionScop}
\begin{comment}
    Copy\&pasted from polly/lib/Analysis/ScopDetection.cpp

    A static control part (Scop) is a subgraph of the control flow graph (CFG)
    that only has statically known control flow and can therefore be described
    within the polyhedral model.

    Every Scop fulfills these restrictions:
    * It is a single entry single exit region
    * Only affine linear bounds in the loops

    Every natural loop in a Scop must have a number of loop iterations that can
    be described as an affine linear function in surrounding loop iterators or
    parameters. (A parameter is a scalar that does not change its value during
    execution of the Scop).
    * Only comparisons of affine linear expressions in conditions
    * All loops and conditions perfectly nested

    The control flow needs to be structured such that it could be written using
    just 'for' and 'if' statements, without the need for any 'goto', 'break' or
    'continue'.

    * Side effect free functions call

    Function calls and intrinsics that do not have side effects (readnone)
    or memory intrinsics (memset, memcpy, memmove) are allowed.
\end{comment}
A \scop is a subgraph of the \cfg that only has statically known control flow and can therefore be described within the polyhedral model.
Every Scop fulfills these restrictions:
\begin{itemize}
    \item It is a single entry single exit region.
    \item Only affine linear bounds in the loops.\\
        Every natural loop in a \scop must have a number of loop iterations that can be described as an affine linear function in surrounding loop iterators or parameters. (A parameter is a scalar that does not change its value during execution of the Scop).
    \item Only comparisons of affine linear expressions in conditions.
    \item All loops and conditions perfectly nested.\\
        The control flow needs to be structured such that it could be written using just \mintinline{c++}{for} and \mintinline{c++}{if} statements, without the need for any \mintinline{c++}{goto}, \mintinline{c++}{break} or \mintinline{c++}{continue}.
    \item Side effect free functions call.\\
        Function calls and intrinsics that do not have side effects (readnone) or \enquote{emory intrinsics (memset, memcpy, memmove) are allowed}.
\end{itemize}
